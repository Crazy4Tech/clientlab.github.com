---
layout: post
category: lessons
title: 语义化版本控制 2.0.0
tagline: 语义化版本控制 2.0.0
tags : [开发规范]
---
{% include JB/setup %}

> 译者注1：Semantic Versioning 2.0.0的原文地址是[http://semver.org](http://semver.org)

## 概要 ##

版本号MAJOR.MINOR.PATCH（主版本号.副版本号.补丁版本号）的递增规则如下：

1. 当以不向后兼容的方式，变更API时，递增主版本号。
2. 当以向后兼容的方式，增加功能时，递增副版本号。
3. 当以向后兼容的方式，修正BUG时，递增补丁版本号。

预发布信息和构建元数据可以作为附加标签，扩展MAJOR.MINOR.PATCH（主版本号.副版本号.补丁版本号）的格式。

## 引言 ##

在软件开发管理的世界里，有一个可怕的地方叫做“依赖关系地狱”。当你的系统越来越大，集成了更多的包，你就会深刻的认识到自己的卑微和渺小。直到有一天，你在这个坑里彻底绝望。

系统依赖的模块发布新版本，就成了噩梦。如果依赖关系的规定过于严格，会遇到一个版本依赖关系的死结（升级一个依赖包之前，必须升级完所有的依赖包）。如果依赖关系规定的太松散，版本依赖关系的混乱就会成为你的切肤之痛（假定你的版本兼容性很重要）。当版本依赖关系的死结、混乱，让你不能轻松、安全的向前迁移项目的时，你就坠入了“依赖关系地狱”。

为了解决这个问题，我提出了一套简单的规则和要求，决定版本号如何分配和递增。这些规则都是基于（但不限于）业界早已存在的流行做法。使用此制度的软件必须声明一个公共API，可以在代码内部声明，也可以严格地写入文档中，但必须是清晰而准确的。一旦确定了公共API，都必须通过明确的版本号递增，来表明系统所做的变更。认真考虑一下X.Y.Z（主版本号.副版本号.补丁版本号）的版本格式。不影响API的BUG修正,递增补丁版本号。向后兼容API的功能新增或变更，递增副版本号。不向后兼容的API变更，递增主版本号。

我把这个制度称为“语义化版本控制”。在这个方案中，规范了从一个版本到下一个版本的版本号，规范了更改版本号传达源代码意图的方法，以及源代码做了什么样的修改。

## 语义化版本控制规范（SemVer） ##

在本文档中，对关键词（"MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"）的使用，遵循[RFC2119标准](http://tools.ietf.org/html/rfc2119)的规范。

> 译者注2：RFC2119标准规范了表示“要求”（Requirement）的动词涵义。关于RFC2119标准可以参考《[RFC2119 中文版-RFC文档用于指出要求级别的关键字](http://blog.csdn.net/bryangg/article/details/2443488)》。

1. 使用语义化版本控制的软件必须（MUST）声明一个公共的API。这个API可以在源代码的内部声明，也可以在文档中严格的定义。无论怎么做，都应该是清晰而全面的。
2. 一个标准的版本号必须（MUST）是X.Y.Z的形式。其中的X、Y和Z都要是正整数，并且禁止（MUST NOT）包含前导零。X是主版本号，Y是副版本号，Z是补丁版本号。每个元素数字的递增，必须（MUST）是1。例如：`1.9.0 -> 1.10.0 -> 1.110`
3. 一旦发布一个包的版本，该版本的内容禁止（MUST NOT）再做任何修改。任何的修改都必须（MUST）发布一个新的版本。
4. 主版本0（0.y.z）用于初始开发。此时的公共API随时都可能会改动，是不稳定的。
5. 在1.0.0版本中，公共API作出正式的定义。后续的版本号变更，都决定于公共API是否变更，以及如何变更。
6. 以向后兼容的方式修正BUG时，必须（MUST）递增补丁版本号Z(x.y.Z | x > 0)。BUG修正的定义，是在源代码内部修正错误的行为。
7. 当以向后兼容的方式变更公共API时，或者公共API中原有的功能标记为“不建议使用（deprecated）”时，必须（MUST）递增副版本号Y(x.Y.z | x > 0 )。源代码内部大量增加、修改功能时，也可以（MAY）递增副版本号。副版本号的递增可以（MAY）包括补丁版本的更新内容。副版本号递增后，补丁版本号必须（MUST）重置为0。
8. 当以不向后兼容性的方式，变更公共API时，必须（MUST）递增主版本号X(X.y.z | X > 0)，可以（MAY）包含副版本和补丁版本级别的变更。主版本递增后，副版本号和补丁版本号必须（MUST）重置为0。
9. 预发布的版本号，可以（MAY）在补丁版本号后面，添加一个破折号和一系列被点分割的标识符。这些标识符必须（MUST）由ASCII码中的字母和数字以及连字符[0-9A-Za-z-]组成。标识符禁止（MUST NOT）为空。数字禁止（MUST NOT）包含前导0。预发布版本号的优先级比正常的版本号低。预发布版本号表示该版本是不稳定的，可能无法达到其指明的正常版本号的兼容性预期。例如：`1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92`。
10. 构建的元数据，可以（MAY）在补丁版本号或预发布版本号后面，添加一个加号和一系列由连字符分隔的标示符组成。这些标识符必须（MUST）由ASCII码中的字母和数字以及连字符[0-9A-Za-z-]组成。标识符禁止（MUST NOT）为空。在确定版本号的优先级时，构建元数据应该（SHOULD）被忽略。因此，如果两个版本号的差异，仅仅在于构建元数据，就视为具有相同的优先级。例如：`1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85`。
11. 优先级是指在排序时，版本号之间如何进行比较。优先级必须（MUST）是，根据版本号按照主版本号、副版本号、补丁版本号和预发布标识的顺序进行计算产生的（构建元数据不参与优先级的比较）。优先级总是从左到右的，依次比较主版本号、副版本号、补丁版本号的数字大小。例如：`1.0.0 < 2.0.0 < 2.1.0 < 2.1.1`。在主版本号、副版本号、补丁版本号都相同时，预发布版本号的优先级低于正常版本号。例如：`1.0.0-alpha < 1.0.0`。两个预发布版本号的主版本号、副版本号、补丁版本号都相同时，优先级必须（MUST）从左至右的比较由点分隔的标识符，直到发现差异。标识符仅由数字组成的，比较数字的大小。标识符包含字母或连字符的，按照ASCII码的顺序进行比较。数字标识符总是小于非数字标识符。如果前面所有的标识符都是相同的，版本号中预发布字段较长的，优先级较高。例如：`1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0`。

## 为什么要使用语义化版本控制 ##

语义化版本控制并不新鲜，也不是一个革命性的想法。事实上，你可能做了很多，已经完成了这件事。问题是完成并不是极致。如果不符合某种正式的规范，版本号在依赖关系管理上基本没有什么用处。给上述想法起个名字，做出清晰的定义，就很容易向软件用户传达你的意图。一旦这些意图是明确的，一个灵活的（但也不能太灵活）依赖关系管理规范，就流畅的运转起来了。

举一个简单的例子，说明语义化版本控制如何把你从“依赖关系地狱”中拯救出来。设想一个叫“消防车”的库，依赖一个使用语义化版本控制的包，名叫“梯子”。“消防车”刚刚生产出来的时候，梯子的版本号是3.1.0。由于“消防车”使用了在3.1.0版本才开始提供的一些功能，你就可以放心地指定依赖的“梯子”的版本大于等于3.1.0，但低于4.0.0。现在，当“梯子”有3.1.1和3.2.0的版本可用时，就可以更新到你的包管理系统，并知道他们将与当前依赖的软件兼容。

作为一个负责任开发者，你当然会验证任何包所标榜的新功能。现实世界可是一个鱼龙混杂的地方，做什么事情都可以，但要警惕。你可以让语义化版本控制，给你提供一个稳健的方式来发布和升级包，不必再被迫为使用依赖包的新版本而反复折腾，为你节省时间，减少麻烦。

如果这一切听起来还不错，你需要做的所有事情，就是开始声明你正在使用语义化版本控制，并遵循其规则。欢迎你在README文档中链接这个网站(译者注3)，让更多的人知道这个规则，并从中受益。

> 译者注3：原文中提到的网站是指[http://semver.org](http://semver.org)。如果你愿意，也欢迎你加上本文的链接地址[http://clientlab.github.io/studio/2013/11/16/semantic-versioning-2.0.0/](http://clientlab.github.io/studio/2013/11/16/semantic-versioning-2.0.0/)，让更多使用中文的人知道这些规则，并从中受益。

## 常见问题 ##

## 关于作者 ##

语义化版本控制规范是由[Tom Preston-Werner](http://tom.preston-werner.com/)编写的。他是[Gravatars](http://en.gravatar.com/) 的创始人，也是[GitHub](https://github.com/)的共同创办人。

如果你有一些反馈，可以在[GitHub上提交一个问题](https://github.com/mojombo/semver/issues)。

## 许可证 ##

[知识共享 - CC 3.0](http://creativecommons.org/licenses/by/3.0/)

## 参考资料 ##

- [语义化版本号 Sematic Versioning(http://www.fallhunter.com/p/10555)](http://www.fallhunter.com/p/10555)
- [Semantic Versioning 语义化版本号(http://blog.neekey.me/blog/2012/02/27/semantic-versioning/)](http://blog.neekey.me/blog/2012/02/27/semantic-versioning/)
- [RFC2119 中文版-RFC文档用于指出要求级别的关键字](http://blog.csdn.net/bryangg/article/details/2443488)